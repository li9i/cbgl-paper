%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Motivation}
\label{subsec:motivation}

The proposed method's motivation lies in the simple but powerful fact that in
general is exhibited through fig. \ref{fig:motivation_caer}: Let a pose
estimate of a 2D LIDAR sensor be in a neighbourhood of its true pose within a
given map (Def. \ref{def:definition_0}); then the value of the CAER metric
(Def.  \ref{def:definition_3}) between the scan measured by the sensor (Def.
\ref{def:definition_1}) and the map-scan captured from the estimate within the
map (Def. \ref{def:definition_2}) is proportional to both the estimate's
location error and orientation error. In other words comparing any two pose
estimates residing in a neighbourhood of the sensor's pose in terms of a scalar
value is enough to establish a pose error hierarchy between them. Moreover,
this scalar locus metric is directly derivable and calculable from the
assumptions of Problem \ref{prob:the_problem}, with low computational
complexity $\mathcal{O}(N_s)$.

The relationships of proportionality between the CAER metric of a pose
estimate and its location and orientation errors have been discovered and
successfully exploited in the context of non-global localisation, and
specifically in pose-tracking, for the production of lidar odometry
\cite{Filotheou2022f} and the reduction of localisation's pose estimate error
\cite{Filotheou2023a}. In this context, estimate errors are close to the
origin, i.e. in contrast to the arbitrary distribution of hypotheses' errors in
Monte Carlo global localisation methods.


\begin{figure}\vspace{-1.5cm}
  \subfloat{\hspace{0.5cm}\input{./figures/caer_all.tex}}\vspace{-1.5cm}\\
  \subfloat{\hspace{-0.3cm}\input{./figures/face_bottom.tex}}
  \caption{\small Top: without loss o generality, a typical plot of the
           Cumulative Absolute Error per Ray metric (Eq. (\ref{eq:caer})) of
           $10^6$ hypotheses disperesed in the map of environment WAREHOUSE
           (Fig. \ref{fig:face} and section \ref{subsec:exp_b}). Bottom:
           focused view on hypotheses with location error close to the origin}
  \vspace{-0.5cm}
  \label{fig:motivation_caer}
\end{figure}


The above motivate investigation on whether the CAER metric could prove equally
beneficial in settings more uncertain than pose-tracking, that is, where the
location and orientation of pose estimates extend farther away from the
sensor's true location and orientation. Fig. \ref{fig:h_and_h_not_fig} (top)
shows the relations between the total errors of hypotheses and
their (a) CAER values (left) and (b) resulting ranks (right),
which resulted from an experimental procedure similar to that which produced fig.
\ref{fig:motivation_caer}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The CBGL System}

In order to test the efficacy of the CAER metric in aiding the solution of
Problem \ref{prob:the_problem}, we introduce the CAER-Based Global Localisation
system (CBGL).\footnote{For a rigorous mathematical formulation of the
hypothesis underpinning CBGL see \cite{cbglarxiv}.} Given map $\bm{M}$, CBGL
first generates a set of pose hypotheses $\mathcal{H}$ (Def.
\ref{def:definition_0}). Their positions are randomly generated
uniformly within the map's traversable space, while orientations within
$[-\pi,\pi)$ rad. Then from these poses it computes map-scans (Def.
\ref{def:definition_2}). Given these map-scans and a LIDAR's 2D measurement
$\mathcal{S}_R$ (Def. \ref{def:definition_1}), CBGL subsequently computes the
CAER value (Def. \ref{def:definition_3}) associated with each pose hypothesis.
It then ranks them in ascending order and selects the $k$ estimates with the
least CAER values in an attempt to estimate the $k$ hypotheses with the least
pose error (Alg. \ref{alg:bottom_k}). Estimation in this sense rests on the
motivation of subsection \ref{subsec:motivation}.

One challenge is choosing such $k$, $d_{\bm{l}}$, and $d_\alpha$ (Def.
\ref{def:definition_6}) that, given pose estimate error requirements
$\delta_{\bm{l}}$, $\delta_{\theta}$, CBGL produces admissible pose estimates
(Def. \ref{def:definition_7}) while being executed in timely manner.  Given the
rank field's Monte Carlo nature, optimistically, the only option for increasing
the accuracy of the final pose estimate by a factor of two would be to double
the densities of the \texttt{r}-field; instead of doing that---and thereby
doubling the method's execution time---subsequent to the estimation of the pose
estimates with the $k$ lowest CAER values, CBGL utilises scan--to--map-scan
matching \cite{Vasiljevic2016c,Filotheou2023a}, followed by the estimation of
the one pose estimate with the lowest CAER value within the group of $k$
matched estimates.

Matching allows for (a) the correction of the pose of true positive estimates
by scan-matching the map-scan captured from a pose estimate against the range
scan measured by the real sensor, (b) by the same token the potential
divergence of spurious, false positive, pose estimates, and hence their
elimination as pose estimate candidates, (c) the production of finer pose
estimates without excessive increase in execution time, and (d) the decoupling
of the final pose estimate's error from the field's densities.

CBGL's output pose estimate is that with the least CAER among the $k$ matched
estimates. CBGL is described in block diagram form in figure
\ref{fig:block_system} (left) and in pseudocode in Algorithm \ref{alg:cbgl}.


\begin{figure}\vspace{-0.4cm}
  \subfloat{\label{fig:cbgl}     \input{./figures/cbgl_system_tiny.tikz}}
  \subfloat{\label{fig:bottom_k} \input{./figures/inner_ranking_system2_tiny.tikz}}
  \caption{\small CBGL in block diagram form. Left: Given map $\bm{M}$, CBGL
           first generates a set of pose hypotheses $\mathcal{H}$. Then it
           estimates the $k$ hypotheses with the least pose error (right; Alg.
           \ref{alg:bottom_k}).
           %II \cite{Filotheou2023c}
           As a final step, it scan--to--map-scan
           matches these to $\mathcal{S}_R$ for finer estimation
           (\texttt{sm2}; Alg.
           \ref{alg:sm2}).
           %III \cite{Filotheou2023c}
           CBGL's output pose estimate is that with
           the minimum CAER among the $k$ matched estimates
           }
\vspace{-0.5cm}
  \label{fig:block_system}
\end{figure}


%%% CBGL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}[]
  \caption{\texttt{CBGL}}
  \begin{spacing}{1.0}
  \begin{algorithmic}[1]
    \REQUIRE $\mathcal{S}_R$, $\lambda$, $\bm{M}$, $(d_{\bm{l}}, d_\alpha)$, $k$
    \ENSURE Pose estimate of sensor measuring range scan $\mathcal{S}_R$ %$\hat{\bm{p}}$
    \STATE $A \leftarrow \texttt{calculate\_area}(\texttt{free}(\bm{M}))$
    \STATE $\mathcal{H} \leftarrow \{\varnothing\}$
    \FOR {$i \leftarrow 0,1,\dots,d_{\bm{l}} \cdot A-1$}
      \STATE \small $(\hat{x},\hat{y},\hat{\theta}) \leftarrow \texttt{rand()}$: $(x,y) \in \texttt{free}(\bm{M})$, $\hat{\theta} \in [-\pi,+\pi)$
      \FOR {$j \leftarrow 0,1,\dots, d_{\alpha}-1$}
        \STATE $\mathcal{H} \leftarrow \{\mathcal{H}, (\hat{x}, \hat{y}, \hat{\theta} + j \cdot 2\pi / d_{\alpha})\}$     \label{alg:cbgl:h}
      \ENDFOR
    \ENDFOR
    \STATE $\mathcal{H}_1 \leftarrow$ \texttt{bottom}$\_k\_\texttt{poses}(\mathcal{S}_R, \bm{M}, \mathcal{H}, k)$ \hfill {\small (Alg. \ref{alg:bottom_k}}) \label{alg:cbgl:h1}
    \STATE $\mathcal{H}_2 \leftarrow \{\varnothing \}$
    \FOR {$k \leftarrow 0,1,\dots,|\mathcal{H}_1|-1$}
      \STATE $\hat{\bm{h}}^\prime \leftarrow \texttt{sm2}(\mathcal{S}_R, \lambda, \bm{M}, \mathcal{H}_1[k])$ \hfill {\small (Alg. \ref{alg:sm2}---e.g. \texttt{x1} \cite{Filotheou2023a}})
      \STATE $\mathcal{H}_2 \leftarrow \{\mathcal{H}_2, \hat{\bm{h}}^\prime\}$  \label{alg:cbgl:h2}
    \ENDFOR
    \RETURN \texttt{bottom}$\_k\_\texttt{poses}(\mathcal{S}_R, \bm{M}, \mathcal{H}_2, 1)$
  \end{algorithmic}
  \end{spacing}
  \label{alg:cbgl}
\end{algorithm}

%% Bottom-n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}[]
  \caption{\texttt{bottom}\_$k$\_\texttt{poses}}
  \begin{spacing}{1.0}
  \begin{algorithmic}[1]
    \REQUIRE $\mathcal{S}_R$, $\bm{M}$, $\mathcal{H}$, $k$
    \ENSURE Set of $k$ poses of $\mathcal{H}$ with least CAER values, $\mathcal{H}_{\triangledown}$
    \STATE $\Psi \leftarrow \{\varnothing \}$
    \FOR {$h \leftarrow 0,1,\dots,|\mathcal{H}|-1$}
      \STATE $\mathcal{S}_V^{\hspace{1pt} h} \leftarrow \texttt{scan\_map}(\bm{M}, \mathcal{H}[h])$
      \STATE $\psi \leftarrow 0$
      \FOR {$n \leftarrow 0,1,\dots,|\mathcal{S}_R|-1$}
        \STATE $\psi \leftarrow \psi + \big|\mathcal{S}_R[n]-\mathcal{S}_V^{\hspace{1pt} h}[n]\big|$ \hfill {\small (Eq. (\ref{eq:caer})})
      \ENDFOR
      \STATE $\Psi \leftarrow \{\Psi, \psi\}$
    \ENDFOR
    \STATE $[\Psi_{\uparrow}, \texttt{I}^{\ast}] \leftarrow \texttt{sort}(\Psi, \texttt{asc})$
    \STATE $\mathcal{H}_{\triangledown} \leftarrow \{\varnothing \}$
    \FOR {$h \leftarrow 0,1,\dots,k-1$}
      \STATE $\mathcal{H}_{\triangledown} \leftarrow \{\mathcal{H}_{\triangledown}, \mathcal{H}[\texttt{I}^{\ast}[h]]\}$
    \ENDFOR
    \RETURN $\mathcal{H}_{\triangledown}$
  \end{algorithmic}
  \end{spacing}
  \label{alg:bottom_k}
\end{algorithm}

%% sm2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}[]
  \caption{\texttt{sm2}}
  \begin{spacing}{1.0}
  \begin{algorithmic}[1]
    \REQUIRE $\mathcal{S}_R$, $\lambda$, $\bm{M}$, $\hat{\bm{p}}$
    %\ENSURE $\hat{\bm{p}}^\prime$
    \ENSURE $\hat{\bm{p}}$ $+$ correction that aligns $\mathcal{S}_V^{\bm{M}}(\hat{\bm{p}})$ to $\mathcal{S}_R$
    \STATE $\mathcal{S}_V \leftarrow \texttt{scan\_map}(\bm{M}, \hat{\bm{p}}, \lambda)$
    \STATE $\bm{\Delta p} \leftarrow \texttt{scan-match}(\mathcal{S}_R,\mathcal{S}_V)$ \hfill {\small (e.g. \texttt{ICP}\cite{Vizzo2023}, \texttt{FSM}\cite{Filotheou2022f}})
    %\STATE $\hat{\bm{p}}^\prime \leftarrow \hat{\bm{p}} + \bm{\Delta p}$
    %\RETURN $\hat{\bm{p}}^\prime$
    \RETURN $\hat{\bm{p}} + \bm{\Delta p}$
  \end{algorithmic}
  \end{spacing}
  \label{alg:sm2}
\end{algorithm}
